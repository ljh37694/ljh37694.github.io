---
layout: posts
title: "백준 16933: 돌 부수고 이동하기 3 c++"
comments: true
---

<br>

## **문제링크**

* <https://www.acmicpc.net/problem/16933>   

![](https://github.com/ljh37694/ljh37694.github.io/blob/main/_captures/Baekjoon16933.PNG?raw=true)

<br>

## **풀이**
* ### **목표**
  * (1,1)에서 (n, m)까지 벽을 k번 부수고 이동할 때 최소거리 구한다.
  * 단, 낮일 때만 벽을 부술 수 있다.

<br>

* ### **중점**
  * 한 칸 움직일 때마다 낮과 밤이 바뀐다.
  * 낮일 때만 벽을 부술 수 있다.
  * 0~k번 벽을 부수고 어느 좌표에 도착한 적이 있는지 저장할 수 있는 배열을 이용한다.
  * k번 벽을 부쉈을 때 벽을 만나면 더이상 벽을 부술 수 없다.

<br>

## **코드**
``` c++
// 16946: 벽 부수고 이동하기 4

#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
#include <set>

using namespace std;

struct Pos {
public:
	int y, x, cnt = 0, level;
	bool night; // 밤이면 true

	Pos(int y = 0, int x = 0, bool night = true, int cnt = 0, int level = 0) : y(y), x(x), night(night), cnt(cnt), level(level) {}
};

class CrushWallAndMove {
private:
	int n, m, k;
	vector<vector<int>> map;
	const int dy[4] = { -1, 1, 0, 0 }, dx[4] = { 0, 0, -1, 1 }; // 상하좌우

	// 초기화
	void init();

	// 유효한 좌표면 true, 아니면 false
	bool isValid(Pos p) { return (0 <= p.y && p.y < n) && (0 <= p.x && p.x < m); }

	void bfs();

public:
	CrushWallAndMove();
};

CrushWallAndMove::CrushWallAndMove() {
	init();

	bfs();
}

void CrushWallAndMove::init() {
	cin >> n >> m >> k;

	map.assign(n, vector<int>(m));

	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			char c; cin >> c;

			map[i][j] = c - '0';
		}
	}
}

void CrushWallAndMove::bfs() {
	queue<Pos> q;

	q.push(Pos(0, 0, false, 0, 1));

	vector<vector<vector<bool>>> v(k + 1, vector<vector<bool>>(n, vector<bool>(m)));

	for (int i = 0; i <= k; i++) {
		v[i][0][0] = true;
	}

	while (!q.empty()) {
		Pos cur = q.front();

		// 목표 지점에 도착했을 때
		if (cur.y == n - 1 && cur.x == m - 1) {
			cout << cur.level;

			return;
		}

		for (int i = 0; i < 4; i++) {
			Pos p(cur.y + dy[i], cur.x + dx[i], !cur.night, cur.cnt, cur.level + 1);

			// 유효한 좌표가 아니면 continue
			if (!isValid(p)) continue;

			// 다음 칸이 벽일 때
			if (map[p.y][p.x] == 1) {
				// 낮일 때
				if (!cur.night) {
					// 벽을 k번 부쉈다면 continue
					if (p.cnt == k || v[p.cnt + 1][p.y][p.x]) continue;

					p.cnt++;
				}

				// 밤일 때
				else {
					p = cur;

					p.night = false;
					p.level++;
				}
			}

			// 다음 칸이 빈칸일 때
			else {
				if (v[p.cnt][p.y][p.x]) continue;
			}

			v[p.cnt][p.y][p.x] = true;
			q.push(p);
		}

		q.pop();
	}

	cout << -1;
}

int main(void) {
	ios::sync_with_stdio(0);
	cin.tie(0);

	CrushWallAndMove cwm;

	return 0;
}
```